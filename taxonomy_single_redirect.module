<?php

/**
 * @file
 * Primary module hooks for Taxonomy Single Redirect module. 1.0.0
 */

use Drupal\Core\Url;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Routing\TrustedRedirectResponse;

/**
 * Implements hook_entity_view().
 */
function taxonomy_single_redirect_entity_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  
  // 1. Target only taxonomy terms in 'full' view mode.
  if ($entity->getEntityTypeId() !== 'taxonomy_term' || $view_mode !== 'full') {
    return;
  }

  $config = \Drupal::config('taxonomy_single_redirect.settings');
  if (!$config->get('enabled')) {
    return;
  }

  /** @var \Drupal\taxonomy\TermInterface $entity */
  $term_id = $entity->id();
  
  // 2. Dynamic discovery of reference fields.
  $field_manager = \Drupal::service('entity_field.manager');
  $entity_type_bundle_info = \Drupal::service('entity_type.bundle.info');
  $node_bundles = array_keys($entity_type_bundle_info->getBundleInfo('node'));
  $relevant_fields = [];

  foreach ($node_bundles as $bundle) {
    $fields = $field_manager->getFieldDefinitions('node', $bundle);
    foreach ($fields as $field_name => $field_definition) {
      if ($field_definition->getType() === 'entity_reference' && 
          $field_definition->getSetting('target_type') === 'taxonomy_term') {
        $relevant_fields[$field_name] = $field_name;
      }
    }
  }

  if (empty($relevant_fields)) {
    return;
  }

  // 3. Query for nodes.
  $query = \Drupal::entityTypeManager()->getStorage('node')->getQuery()
    ->condition('status', 1)
    ->accessCheck(TRUE);

  $or_group = $query->orConditionGroup();
  foreach ($relevant_fields as $field_name) {
    $or_group->condition($field_name . '.target_id', $term_id);
  }

  $nids = $query->condition($or_group)->range(0, 2)->execute();
  $nids = array_unique($nids);

  // 4. Build Cache Metadata.
  // Instead of creating new metadata, we apply tags/contexts directly to the build array
  // to ensure Drupal merges them with the global system contexts (theme, language, etc.).
  $build['#cache']['tags'] = array_merge($build['#cache']['tags'] ?? [], ['node_list']);
  $build['#cache']['tags'] = array_merge($build['#cache']['tags'], $entity->getCacheTags());
  $build['#cache']['contexts'][] = 'url.path';

  // 5. Check for single node and perform redirect via Response object.
  if (count($nids) === 1) {
    $nid = reset($nids);
    $url = Url::fromRoute('entity.node.canonical', ['node' => $nid])->setAbsolute()->toString();
    
    // We use a TrustedRedirectResponse but we don't throw it.
    // Instead, we let Drupal's render pipeline handle the redirection.
    $response = new TrustedRedirectResponse($url, 302);
    
    // Attach cacheable metadata to the response so the redirect itself is cached.
    $cache_metadata = CacheableMetadata::createFromRenderArray($build);
    $response->addCacheableDependency($cache_metadata);

    // For anonymous users and Page Cache compatibility, we set the response.
    $build['#attached']['http_header'][] = ['Location', $url];
    
    // This is the cleanest way to trigger a redirect in hook_entity_view
    // without breaking the VariationCache contexts.
    $response->send();
    exit;
  }
}
